/*
 * Copyright (c) 2019 TAOS Data, Inc. <jhtao@taosdata.com>
 *
 * This program is free software: you can use, redistribute, and/or modify
 * it under the terms of the MIT license as published by the Free Software
 * Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include "bench.h"

#define SHOW_PARSE_RESULT_START_TO_FILE(fp)                               \
    do {                                                                  \
        if (g_arguments->metaFile)                                        \
            fprintf(fp,                                                   \
                    "\033[1m\033[40;32m================ %s parse result " \
                    "START ================\033[0m\n",                    \
                    g_arguments->metaFile);                               \
    } while (0)

#define SHOW_PARSE_RESULT_END_TO_FILE(fp)                                 \
    do {                                                                  \
        if (g_arguments->metaFile)                                        \
            fprintf(fp,                                                   \
                    "\033[1m\033[40;32m================ %s parse result " \
                    "END================\033[0m\n",                       \
                    g_arguments->metaFile);                               \
    } while (0)

void printfInsertMetaToFileStream(FILE *fp) {
    setupForAnsiEscape();
    SHOW_PARSE_RESULT_START_TO_FILE(fp);

    if (g_arguments->demo_mode) {
        fprintf(
            fp,
            "\ntaosBenchmark is simulating data generated by power equipment "
            "monitoring...\n\n");
    } else {
        fprintf(
            fp,
            "\ntaosBenchmark is simulating random data as you request..\n\n");
    }
    fprintf(fp, "host:                       \033[33m%s\033[0m\n",
            g_arguments->host);
    fprintf(fp, "port:                       \033[33m%u\033[0m\n",
            g_arguments->port);
    fprintf(fp, "telnet_tcp_port:            \033[33m%u\033[0m\n",
            g_arguments->telnet_tcp_port);
    fprintf(fp, "user:                       \033[33m%s\033[0m\n",
            g_arguments->user);
    fprintf(fp, "password:                   \033[33m%s\033[0m\n",
            g_arguments->password);
    fprintf(fp, "configDir:                  \033[33m%s\033[0m\n", configDir);
    fprintf(fp, "resultFile:                 \033[33m%s\033[0m\n",
            g_arguments->output_file);
    fprintf(fp, "thread num of insert data:  \033[33m%d\033[0m\n",
            g_arguments->nthreads);
    fprintf(fp, "thread num of create table: \033[33m%d\033[0m\n",
            g_arguments->nthreads);
    fprintf(fp, "number of records per req:  \033[33m%u\033[0m\n",
            g_arguments->reqPerReq);
    fprintf(fp, "random prepare data size:   \033[33m%" PRId64 "\033[0m\n",
            g_arguments->prepared_rand);
    fprintf(fp, "chinese:                    \033[33m%s\033[0m\n",
            g_arguments->chinese ? "yes" : "no");

    fprintf(fp, "database count:             \033[33m%d\033[0m\n",
            g_arguments->dbCount);

    for (int i = 0; i < g_arguments->dbCount; i++) {
        fprintf(fp, "database[\033[33m%d\033[0m]:\n", i);
        fprintf(fp, "  database[%d] name:      \033[33m%s\033[0m\n", i,
                g_arguments->db[i].dbName);
        if (0 == g_arguments->db[i].drop) {
            fprintf(fp, "  drop:                 \033[33m no\033[0m\n");
        } else {
            fprintf(fp, "  drop:                 \033[33m yes\033[0m\n");
        }

        if (g_arguments->db[i].dbCfg.blocks >= 0) {
            fprintf(fp, "  blocks:                \033[33m%d\033[0m\n",
                    g_arguments->db[i].dbCfg.blocks);
        }
        if (g_arguments->db[i].dbCfg.cache >= 0) {
            fprintf(fp, "  cache:                 \033[33m%d\033[0m\n",
                    g_arguments->db[i].dbCfg.cache);
        }
        if (g_arguments->db[i].dbCfg.days >= 0) {
            fprintf(fp, "  days:                  \033[33m%d\033[0m\n",
                    g_arguments->db[i].dbCfg.days);
        }
        if (g_arguments->db[i].dbCfg.keep >= 0) {
            fprintf(fp, "  keep:                  \033[33m%d\033[0m\n",
                    g_arguments->db[i].dbCfg.keep);
        }
        if (g_arguments->db[i].dbCfg.replica > 0) {
            fprintf(fp, "  replica:               \033[33m%d\033[0m\n",
                    g_arguments->db[i].dbCfg.replica);
        }
        if (g_arguments->db[i].dbCfg.update >= 0) {
            fprintf(fp, "  update:                \033[33m%d\033[0m\n",
                    g_arguments->db[i].dbCfg.update);
        }
        if (g_arguments->db[i].dbCfg.minRows >= 0) {
            fprintf(fp, "  minRows:               \033[33m%d\033[0m\n",
                    g_arguments->db[i].dbCfg.minRows);
        }
        if (g_arguments->db[i].dbCfg.maxRows >= 0) {
            fprintf(fp, "  maxRows:               \033[33m%d\033[0m\n",
                    g_arguments->db[i].dbCfg.maxRows);
        }
        if (g_arguments->db[i].dbCfg.comp >= 0) {
            fprintf(fp, "  comp:                  \033[33m%d\033[0m\n",
                    g_arguments->db[i].dbCfg.comp);
        }
        if (g_arguments->db[i].dbCfg.walLevel >= 0) {
            fprintf(fp, "  walLevel:              \033[33m%d\033[0m\n",
                    g_arguments->db[i].dbCfg.walLevel);
        }
        if (g_arguments->db[i].dbCfg.fsync >= 0) {
            fprintf(fp, "  fsync:                 \033[33m%d\033[0m\n",
                    g_arguments->db[i].dbCfg.fsync);
        }
        if (g_arguments->db[i].dbCfg.quorum > 0) {
            fprintf(fp, "  quorum:                \033[33m%d\033[0m\n",
                    g_arguments->db[i].dbCfg.quorum);
        }
        fprintf(fp, "  precision:             \033[33m%s\033[0m\n",
                g_arguments->db[i].dbCfg.precision == TSDB_TIME_PRECISION_MILLI
                    ? "ms"
                    : g_arguments->db[i].dbCfg.precision ==
                              TSDB_TIME_PRECISION_MICRO
                          ? "us"
                          : "ns");

        fprintf(fp, "  super table count:     \033[33m%" PRIu64 "\033[0m\n",
                g_arguments->db[i].superTblCount);
        for (uint64_t j = 0; j < g_arguments->db[i].superTblCount; j++) {
            fprintf(fp, "  super table[\033[33m%" PRIu64 "\033[0m]:\n", j);

            fprintf(fp, "      stbName:           \033[33m%s\033[0m\n",
                    g_arguments->db[i].superTbls[j].stbName);

            fprintf(fp, "      interface:         \033[33m%s\033[0m\n",
                    (g_arguments->db[i].superTbls[j].iface == TAOSC_IFACE)
                        ? "taosc"
                        : (g_arguments->db[i].superTbls[j].iface == REST_IFACE)
                              ? "rest"
                              : (g_arguments->db[i].superTbls[j].iface ==
                                 STMT_IFACE)
                                    ? "stmt"
                                    : (g_arguments->db[i].superTbls[j].iface ==
                                       SML_IFACE)
                                          ? "sml"
                                          : "sml-rest");

            if (g_arguments->db[i].superTbls[j].autoCreateTable) {
                fprintf(fp, "      autoCreateTable:   \033[33m%s\033[0m\n",
                        "yes");
            } else {
                fprintf(fp, "      autoCreateTable:   \033[33m%s\033[0m\n",
                        "no");
            }

            if (g_arguments->db[i].superTbls[j].childTblExists) {
                fprintf(fp, "      childTblExists:    \033[33m%s\033[0m\n",
                        "yes");
            } else {
                fprintf(fp, "      childTblExists:    \033[33m%s\033[0m\n",
                        "no");
            }

            fprintf(fp, "      childTblCount:     \033[33m%" PRId64 "\033[0m\n",
                    g_arguments->db[i].superTbls[j].childTblCount);
            fprintf(fp, "      childTblLimit:     \033[33m%" PRIu64 "\033[0m\n",
                    g_arguments->db[i].superTbls[j].childTblLimit);
            fprintf(fp, "      childTblOffset:    \033[33m%" PRIu64 "\033[0m\n",
                    g_arguments->db[i].superTbls[j].childTblOffset);
            fprintf(fp, "      childTblPrefix:    \033[33m%s\033[0m\n",
                    g_arguments->db[i].superTbls[j].childTblPrefix);
            fprintf(fp, "      escapeCharacter:   \033[33m%s\033[0m\n",
                    g_arguments->db[i].superTbls[j].escape_character ? "yes"
                                                                     : "no");
            if (g_arguments->db[i].superTbls[j].random_data_source) {
                fprintf(fp, "      dataSource:        \033[33m%s\033[0m\n",
                        "random");
            } else {
                fprintf(fp, "      dataSource:        \033[33m%s\033[0m\n",
                        "sample");
            }

            if (g_arguments->db[i].superTbls[j].iface == SML_IFACE ||
                g_arguments->db[i].superTbls[j].iface == SML_REST_IFACE) {
                fprintf(fp, "      lineProtocol:      \033[33m%s\033[0m\n",
                        (g_arguments->db[i].superTbls[j].lineProtocol ==
                         TSDB_SML_LINE_PROTOCOL)
                            ? "line"
                            : (g_arguments->db[i].superTbls[j].lineProtocol ==
                               TSDB_SML_TELNET_PROTOCOL)
                                  ? "telnet"
                                  : "json");
                if (g_arguments->db[i].superTbls[j].iface == SML_REST_IFACE &&
                    g_arguments->db[i].superTbls[j].lineProtocol ==
                        TSDB_SML_TELNET_PROTOCOL) {
                    fprintf(fp, "      tcpTransfer:       \033[33m%s\033[0m\n",
                            g_arguments->db[i].superTbls[j].tcpTransfer ? "yes"
                                                                        : "no");
                }
            }

            if (g_arguments->db[i].superTbls[j].childTblOffset > 0) {
                fprintf(fp,
                        "      childTblOffset:    \033[33m%" PRIu64 "\033[0m\n",
                        g_arguments->db[i].superTbls[j].childTblOffset);
            }
            fprintf(fp, "      insertRows:        \033[33m%" PRId64 "\033[0m\n",
                    g_arguments->db[i].superTbls[j].insertRows);
            fprintf(fp, "      interlaceRows:     \033[33m%u\033[0m\n",
                    g_arguments->db[i].superTbls[j].interlaceRows);

            if (g_arguments->db[i].superTbls[j].interlaceRows > 0) {
                fprintf(fp,
                        "      stable insert interval:   \033[33m%" PRIu64
                        "\033[0m\n",
                        g_arguments->db[i].superTbls[j].insert_interval);
            }

            fprintf(fp, "      disorderRange:     \033[33m%d\033[0m\n",
                    g_arguments->db[i].superTbls[j].disorderRange);
            fprintf(fp, "      disorderRatio:     \033[33m%d\033[0m\n",
                    g_arguments->db[i].superTbls[j].disorderRatio);
            fprintf(fp, "      timeStampStep:     \033[33m%" PRId64 "\033[0m\n",
                    g_arguments->db[i].superTbls[j].timestamp_step);
            fprintf(fp, "      startTimestamp:    \033[33m%" PRIu64 "\033[0m\n",
                    g_arguments->db[i].superTbls[j].startTimestamp);
            fprintf(fp, "      sampleFile:        \033[33m%s\033[0m\n",
                    g_arguments->db[i].superTbls[j].sampleFile);
            fprintf(fp, "      useSampleTs:       \033[33m%s\033[0m\n",
                    g_arguments->db[i].superTbls[j].useSampleTs
                        ? "yes (warning: disorderRange/disorderRatio is "
                          "disabled)"
                        : "no");
            fprintf(fp, "      tagsFile:          \033[33m%s\033[0m\n",
                    g_arguments->db[i].superTbls[j].tagsFile);
            fprintf(fp, "      partialColCount:   \033[33m%d\033[0m\n",
                    g_arguments->db[i].superTbls[j].partialColumnNum);
            fprintf(fp, "      columnCount:       \033[33m%d\033[0m\n        ",
                    g_arguments->db[i].superTbls[j].columnCount);
            for (int k = 0; k < g_arguments->db[i].superTbls[j].columnCount;
                 k++) {
                if ((g_arguments->db[i].superTbls[j].col_type[k] ==
                     TSDB_DATA_TYPE_NCHAR) ||
                    (g_arguments->db[i].superTbls[j].col_type[k] ==
                     TSDB_DATA_TYPE_BINARY)) {
                    fprintf(fp, "column[%d]:\033[33m%s(%d)\033[0m ", k,
                            taos_convert_datatype_to_string(
                                g_arguments->db[i].superTbls[j].col_type[k]),
                            g_arguments->db[i].superTbls[j].col_length[k]);
                } else {
                    fprintf(fp, "column[%d]:\033[33m%s\033[0m ", k,
                            taos_convert_datatype_to_string(
                                g_arguments->db[i].superTbls[j].col_type[k]));
                }
            }
            fprintf(fp, "\n");

            fprintf(fp,
                    "      tagCount:            \033[33m%d\033[0m\n        ",
                    g_arguments->db[i].superTbls[j].tagCount);
            for (int k = 0; k < g_arguments->db[i].superTbls[j].tagCount; k++) {
                if ((g_arguments->db[i].superTbls[j].tag_type[k] ==
                     TSDB_DATA_TYPE_BINARY) ||
                    (g_arguments->db[i].superTbls[j].tag_type[k] ==
                     TSDB_DATA_TYPE_NCHAR)) {
                    fprintf(fp, "tag[%d]:\033[33m%s(%d)\033[0m ", k,
                            taos_convert_datatype_to_string(
                                g_arguments->db[i].superTbls[j].tag_type[k]),
                            g_arguments->db[i].superTbls[j].tag_length[k]);
                } else if (g_arguments->db[i].superTbls[j].tag_type[k] ==
                           TSDB_DATA_TYPE_JSON) {
                    fprintf(fp,
                            "tag[%d]:\033[33mjson{key(%d):value(%d)}\033[0m ",
                            k, g_arguments->db[i].superTbls[j].tagCount,
                            g_arguments->db[i].superTbls[j].tag_length[k]);
                    break;
                } else {
                    fprintf(fp, "tag[%d]:\033[33m%s\033[0m ", k,
                            taos_convert_datatype_to_string(
                                g_arguments->db[i].superTbls[j].tag_type[k]));
                }
            }
            fprintf(fp, "\n");
        }

        fprintf(fp, "\n");
    }

    SHOW_PARSE_RESULT_END_TO_FILE(fp);
}

void printfQueryMeta() {
    setupForAnsiEscape();
    SHOW_PARSE_RESULT_START_TO_FILE(stdout);

    printf("host:                           \033[33m%s:%u\033[0m\n",
           g_arguments->host, g_arguments->port);
    printf("user:                           \033[33m%s\033[0m\n",
           g_arguments->user);
    printf("database name:                  \033[33m%s\033[0m\n",
           g_arguments->db->dbName);
    printf("query Mode:                     \033[33m%s\033[0m\n",
           g_arguments->db->superTbls->iface == REST_IFACE ? "rest" : "taosc");
    printf("response buffer for restful:    \033[33m%" PRIu64 "\033[0m\n",
           g_queryInfo.response_buffer);
    printf("reset query cache:              \033[33m%s\033[0m\n",
           g_queryInfo.reset_query_cache ? "yes" : "no");
    printf("\n");

    if ((SUBSCRIBE_TEST == g_arguments->test_mode) ||
        (QUERY_TEST == g_arguments->test_mode)) {
        printf("specified table query info:                   \n");
        printf("    sqlCount:       \033[33m%d\033[0m\n",
               g_queryInfo.specifiedQueryInfo.sqlCount);
        if (g_queryInfo.specifiedQueryInfo.sqlCount > 0) {
            printf("    specified tbl query times: \033[33m%" PRIu64
                   "\033[0m\n",
                   g_queryInfo.specifiedQueryInfo.queryTimes);
            printf("    query interval: \033[33m%" PRIu64 " ms\033[0m\n",
                   g_queryInfo.specifiedQueryInfo.queryInterval);
            printf("    concurrent:     \033[33m%d\033[0m\n",
                   g_queryInfo.specifiedQueryInfo.concurrent);
            printf("    interval:       \033[33m%" PRIu64 "\033[0m\n",
                   g_queryInfo.specifiedQueryInfo.subscribeInterval);
            printf("    restart:        \033[33m%d\033[0m\n",
                   g_queryInfo.specifiedQueryInfo.subscribeRestart);
            printf("    keepProgress:   \033[33m%d\033[0m\n",
                   g_queryInfo.specifiedQueryInfo.subscribeKeepProgress);

            for (int i = 0; i < g_queryInfo.specifiedQueryInfo.sqlCount; i++) {
                printf("    sql[%d]:    \033[33m%s\033[0m\n", i,
                       g_queryInfo.specifiedQueryInfo.sql[i]);
                printf("    result[%d]: \033[33m%s\033[0m\n", i,
                       g_queryInfo.specifiedQueryInfo.result[i]);
            }
            printf("\n");
        }

        printf("super table query info:\n");
        printf("    sqlCount:       \033[33m%d\033[0m\n",
               g_queryInfo.superQueryInfo.sqlCount);

        if (g_queryInfo.superQueryInfo.sqlCount > 0) {
            printf("    query interval: \033[33m%" PRIu64 "\033[0m\n",
                   g_queryInfo.superQueryInfo.queryInterval);
            printf("    threadCnt:      \033[33m%d\033[0m\n",
                   g_queryInfo.superQueryInfo.threadCnt);
            printf("    childTblCount:  \033[33m%" PRId64 "\033[0m\n",
                   g_queryInfo.superQueryInfo.childTblCount);
            printf("    stable name:    \033[33m%s\033[0m\n",
                   g_queryInfo.superQueryInfo.stbName);
            printf("    stb query times:\033[33m%" PRIu64 "\033[0m\n",
                   g_queryInfo.superQueryInfo.queryTimes);
            printf("    interval:       \033[33m%" PRIu64 "\033[0m\n",
                   g_queryInfo.superQueryInfo.subscribeInterval);
            printf("    restart:        \033[33m%d\033[0m\n",
                   g_queryInfo.superQueryInfo.subscribeRestart);
            printf("    keepProgress:   \033[33m%d\033[0m\n",
                   g_queryInfo.superQueryInfo.subscribeKeepProgress);

            for (int i = 0; i < g_queryInfo.superQueryInfo.sqlCount; i++) {
                printf("    sql[%d]:    \033[33m%s\033[0m\n", i,
                       g_queryInfo.superQueryInfo.sql[i]);
                printf("    result[%d]: \033[33m%s\033[0m\n", i,
                       g_queryInfo.superQueryInfo.result[i]);
            }
            printf("\n");
        }
    }

    SHOW_PARSE_RESULT_END_TO_FILE(stdout);
}

void printStatPerThread(threadInfo *pThreadInfo) {
    if (0 == pThreadInfo->totalDelay) pThreadInfo->totalDelay = 1;

    infoPrint("thread[%d] completed total inserted rows: %" PRIu64
              ", total affected rows: %" PRIu64 ". %.2f records/second\n",
              pThreadInfo->threadID, pThreadInfo->totalInsertRows,
              pThreadInfo->totalAffectedRows,
              (double)(pThreadInfo->totalAffectedRows /
                       ((double)pThreadInfo->totalDelay / 1000000.0)));
}

void display_delay_list(delayList *list) {
    delayNode *index_node = list->head;
    for (uint64_t i = 0; i < list->size; ++i) {
        debugPrint("delayList[%" PRIu64 "]: %" PRIu64 "\n", i,
                   index_node->value);
        index_node = index_node->next;
    }
}
